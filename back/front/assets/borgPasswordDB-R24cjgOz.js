const i="BackupToolDB";const n="borgPasswords";function l(){return new Promise((o,t)=>{const e=indexedDB.open(i,1);e.onupgradeneeded=r=>{const s=r.target.result;s.objectStoreNames.contains(n)||s.createObjectStore(n,{keyPath:"repoPath"})},e.onsuccess=()=>o(e.result),e.onerror=()=>t(e.error)})}async function d(o,t){const e=await l();return new Promise((r,s)=>{const c=e.transaction(n,"readwrite");c.objectStore(n).put({repoPath:o,passphrase:t,savedAt:new Date().toISOString()}),c.oncomplete=()=>{e.close(),r()},c.onerror=()=>{e.close(),s(c.error)}})}async function u(o){const t=await l();return new Promise((e,r)=>{const a=t.transaction(n,"readonly").objectStore(n).get(o);a.onsuccess=()=>{t.close(),e(a.result?.passphrase||null)},a.onerror=()=>{t.close(),r(a.error)}})}async function w(){const o=await l();return new Promise((t,e)=>{const c=o.transaction(n,"readonly").objectStore(n).getAll();c.onsuccess=()=>{o.close(),t(c.result||[])},c.onerror=()=>{o.close(),e(c.error)}})}async function b(o){const t=await l();return new Promise((e,r)=>{const s=t.transaction(n,"readwrite");s.objectStore(n).delete(o),s.oncomplete=()=>{t.close(),e()},s.onerror=()=>{t.close(),r(s.error)}})}async function P(){const o=await l();return new Promise((t,e)=>{const r=o.transaction(n,"readwrite");r.objectStore(n).clear(),r.oncomplete=()=>{o.close(),t()},r.onerror=()=>{o.close(),e(r.error)}})}export{w as a,P as c,b as d,u as g,d as s};
